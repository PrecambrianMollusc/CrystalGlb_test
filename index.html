<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="data:,">
  <meta charset="UTF-8" />
  <title>GLTF Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  //Import modules
  import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
  import { GLTFLoader } from './GLTFLoader.js';
  import { OrbitControls } from './OrbitControls.js';
  
  // renderer , camera, scene, controls
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
 
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
  // Lighting section â€” right after camera
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);
  
  const hemi = new THREE.HemisphereLight(0x88ccff, 0x222244, 0.6);
  scene.add(hemi);
   
  const directional = new THREE.DirectionalLight(0xffffff, 0.2);
  directional.position.set(1, 1, 1);
  scene.add(directional);
    
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  console.log('Attempting to load GLTF...');
  
  // Create a UI container
    const ui = document.createElement('div');
    ui.style.position = 'absolute';
    ui.style.top = '10px';
    ui.style.left = '10px';
    ui.style.background = 'rgba(0,0,0,0.7)';
    ui.style.padding = '10px';
    ui.style.color = 'white';
    ui.style.fontFamily = 'sans-serif';
    ui.style.zIndex = '10';
    document.body.appendChild(ui);
  
  // Functions and helpers
  
  // Create axis label sprites
  function createAxisLabel_old(text, position, color = 0xffffff) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      context.font = '24px sans-serif';
      context.fillStyle = 'white';
      context.fillText(text, 0, 24);
    
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, color });
      const sprite = new THREE.Sprite(material);
      sprite.position.copy(position);
      sprite.scale.set(100, 50, 1);
      return sprite;
  }
     
  function createAxisLabelMesh(text, position, rotation, color = 0xffffff) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
    
      const context = canvas.getContext('2d');
      context.font = '28px sans-serif';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, canvas.width / 2, canvas.height / 2);
    
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        color,
  });
    
      const geometry = new THREE.PlaneGeometry(100, 40);
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.rotation.set(rotation.x, rotation.y, rotation.z);
      return mesh;
  }
  
  const subgroupStates = {
      AllSystems: true,
      Criteria: true,
      IceCrystal: true,
      SilicateCrystal: true,
      PodTrees: true,
      PodSystems: true
  };  
  
  let activeState = 'before'; // default
  const beforeMeshes = {
    AllSystems: [], Criteria: [], IceCrystal: [], SilicateCrystal: [], PodTrees: [], PodSystems: []
  };
  const afterMeshes = {
    AllSystems: [], Criteria: [], IceCrystal: [], SilicateCrystal: [], PodTrees: [], PodSystems: []
  };
  
  function toggleMaster(state) {
    activeState = state;
    updateVisibility();
  }
  
    // call this to refresh what should be visible based on activeState and subgroupStates
    function updateVisibility() {
      Object.keys(subgroupStates).forEach(groupName => {
        const enabled = !!subgroupStates[groupName];
        const beforeGroup = beforeMeshes[groupName] || [];
        const afterGroup  = afterMeshes[groupName]  || [];
    
        beforeGroup.forEach(m => m.visible = (activeState === 'before' && enabled));
        afterGroup.forEach(m  => m.visible = (activeState === 'after'  && enabled));
      });
    }

  
  // enhanced addGroupToggle: reuse for both subgroup and master checkbox
  // If isMaster is true, labelText is used as the master label and groupArray is ignored.
  function addGroupToggle(groupArray, labelText, isMaster = false, groupNameForState = null) {
    const label = document.createElement('label');
    label.style.display = 'block';
    label.style.marginTop = '10px';
  
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = true;
    checkbox.style.marginRight = '6px';
  
    // If this is a subgroup checkbox we register it in subgroupStates
    if (!isMaster) {
      const groupKey = groupNameForState || labelText;
      subgroupStates[groupKey] = true;
  
      checkbox.addEventListener('change', () => {
        subgroupStates[groupKey] = checkbox.checked;
        updateVisibility();
      });
  
      // when created, don't immediately toggle meshes directly; updateVisibility governs visibility
    } else {
      // Master checkbox: checked => before, unchecked => after
      checkbox.addEventListener('change', (e) => {
        activeState = e.target.checked ? 'before' : 'after';
        updateVisibility();
      });
    }
  
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(labelText));
    ui.appendChild(label);
  }

    
  //set up import of model 
  let meshList = [];
  let sphereMesh = []; // ðŸ‘ˆ this will hold meshList[13] once loaded
  let before_allSystems = [];
  let after_allSystems = [];
  let before_criteria = [];
  let after_criteria = [];
  let before_silicateCrystal = [];
  let before_iceCrystal = [];
  let before_podsystems = [];
  let before_podtreesystems = [];
  let after_silicateCrystal = [];
  let after_iceCrystal = [];
  let after_podsystems = [];
  let after_podtreesystems = [];
  
  // load the gtlf file 
  const loader = new GLTFLoader();
  loader.load('https://precambrianmollusc.github.io/IGAU_KeplerRidge_CrystalSurvey/visualization.gltf', gltf => {
    const model = gltf.scene;
    scene.add(model);
    console.log('GLTF loaded:', model);

  // ðŸ” Traverse and log to identoify all scene objects and get rid of any i doint want - I should clean up in the gtlf export!
  scene.traverse(obj => {
    console.log(`Object: ${obj.type}, name: ${obj.name || '(unnamed)'}, visible: ${obj.visible}`);
     if (obj.name === 'mesh14' && obj.type === 'LineSegments') {
      obj.visible = false; // or scene.remove(obj);
      console.log('ðŸ”§ Hiding PyVista bounding box mesh14');
    }

  });
    
    model.traverse(child => {
      if (!(child.isMesh || child.type === 'Points')) return;
      if (child.name === 'mesh0') beforeMeshes.AllSystems.push(child);
      if (child.name === 'mesh1') afterMeshes.AllSystems.push(child);
      if (child.name === 'mesh2') beforeMeshes.Criteria.push(child);
      if (child.name === 'mesh3') afterMeshes.Criteria.push(child);
      if (child.name === 'mesh4') beforeMeshes.PodTrees.push(child);
      if (child.name === 'mesh5') beforeMeshes.PodSystems.push(child);
      if (child.name === 'mesh6') afterMeshes.PodTrees.push(child);
      if (child.name === 'mesh7') afterMeshes.PodSystems.push(child);
      if (['mesh8','mesh9','mesh10','mesh12','mesh13'].includes(child.name)) beforeMeshes.IceCrystal.push(child);
      if (['mesh11','mesh14'].includes(child.name)) beforeMeshes.SilicateCrystal.push(child);
      if (['mesh15','mesh17','mesh19','mesh21','mesh22'].includes(child.name)) afterMeshes.IceCrystal.push(child);
      if (['mesh16','mesh18','mesh20','mesh23'].includes(child.name)) afterMeshes.SilicateCrystal.push(child);
      if (child.name === 'mesh24') sphereMesh = child;
    });
  
    const subgroupStates = {
      AllSystems: true,
      Criteria: true,
      IceCrystal: true,
      SilicateCrystal: true,
      PodTrees: true,
      PodSystems: true
    };
    // point cloud for all beforesystems - should be a low opacity blur
    before_allSystems.material.size = 2.0; // make points larger
    before_allSystems.material.opacity = 0.3;
    before_allSystems.material.transparent = true;
    before_allSystems.material.needsUpdate = true;

    // point cloud for all after systems - should be a low opacity blur
    after_allSystems.material.size = 2.0; // make points larger
    after_allSystems.material.opacity = 0.3;
    after_allSystems.material.transparent = true;
    after_allSystems.material.needsUpdate = true;
  
    // point cloud for the systems that meet criteria but no SPS  we will make this look like spheres
    const sprite_sphere = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
    sprite_sphere.colorSpace = THREE.SRGBColorSpace; // ensures correct color rendering
    console.log('Sprite loaded:', sprite_sphere);

    before_criteria.material.map = sprite_sphere;
    before_criteria.material.size = 10;
    before_criteria.material.opacity = 0.7;
    before_criteria.material.transparent = true;
    before_criteria.material.depthWrite = false; // prevents z-fighting
    before_criteria.material.needsUpdate = true;
    before_criteria.material.blending = THREE.AdditiveBlending;
    
    after_criteria.material.map = sprite_sphere;
    after_criteria.material.size = 10;
    after_criteria.material.opacity = 0.7;
    after_criteria.material.transparent = true;
    after_criteria.material.depthWrite = false; // prevents z-fighting
    after_criteria.material.needsUpdate = true;
    after_criteria.material.blending = THREE.AdditiveBlending;

    // set up the sphere for the raduis of NSPs from the center 
    sphereMesh.material.opacity = 0.3;
    sphereMesh.material.transparent = true;
    sphereMesh.material.depthWrite = false;
    sphereMesh.material.needsUpdate = true;

    // set up the renderings for the differenet NSPs 
       before_silicateCrystal.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.color = new THREE.Color(0x555555);           // slate gray base
            mat.emissive = new THREE.Color(0x111111);        // subtle inner depth
            mat.emissiveIntensity = 0.2;
            mat.metalness = 0.8;                             // high metal content
            mat.roughness = 0.3;                             // polished but not mirror-like
            mat.transparent = false;
            mat.opacity = 1.0;
            mat.depthWrite = true;
            mat.needsUpdate = true;
          });
        });
    // set up the renderings for the differenet NSPs 
       after_silicateCrystal.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.color = new THREE.Color(0x555555);           // slate gray base
            mat.emissive = new THREE.Color(0x111111);        // subtle inner depth
            mat.emissiveIntensity = 0.2;
            mat.metalness = 0.8;                             // high metal content
            mat.roughness = 0.3;                             // polished but not mirror-like
            mat.transparent = false;
            mat.opacity = 1.0;
            mat.depthWrite = true;
            mat.needsUpdate = true;
          });
        });
 
      before_iceCrystal.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.emissive = new THREE.Color(0xeeeeff);       // spectral white
            mat.emissiveIntensity = 0.68;                    // brighter than silicates
            mat.transparent = true;
            mat.opacity = 0.5;                              // soft translucency
            mat.depthWrite = false;
            mat.needsUpdate = true;
          });
        });
      
      after_iceCrystal.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.emissive = new THREE.Color(0xeeeeff);       // spectral white
            mat.emissiveIntensity = 0.68;                    // brighter than silicates
            mat.transparent = true;
            mat.opacity = 0.5;                              // soft translucency
            mat.depthWrite = false;
            mat.needsUpdate = true;
          });
        });


  
      before_podtreesystems.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.emissive = new THREE.Color(0x00ff66);       // spectral green
            mat.emissiveIntensity = 0.5;
            mat.transparent = true;
            mat.opacity = 0.4;
            mat.depthWrite = false;
            mat.needsUpdate = true;
          });
        });
    
      before_podsystems.forEach(mesh => {
        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
        materials.forEach(mat => {
          mat.color = new THREE.Color(0xb87333);          // copper base
          mat.emissive = new THREE.Color(0x552200);       // warm inner glow
          mat.emissiveIntensity = 0.3;
          mat.metalness = 0.6;                            // simulate metal surface
          mat.roughness = 0.4;                            // slight polish
          mat.transparent = true;
          mat.opacity = 0.9;
          mat.depthWrite = true;
          mat.needsUpdate = true;
        });
      });
    
      after_podtreesystems.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.emissive = new THREE.Color(0x00ff66);       // spectral green
            mat.emissiveIntensity = 0.5;
            mat.transparent = true;
            mat.opacity = 0.4;
            mat.depthWrite = false;
            mat.needsUpdate = true;
          });
        });
    
      after_podsystems.forEach(mesh => {
        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
        materials.forEach(mat => {
          mat.color = new THREE.Color(0xb87333);          // copper base
          mat.emissive = new THREE.Color(0x552200);       // warm inner glow
          mat.emissiveIntensity = 0.3;
          mat.metalness = 0.6;                            // simulate metal surface
          mat.roughness = 0.4;                            // slight polish
          mat.transparent = true;
          mat.opacity = 0.9;
          mat.depthWrite = true;
          mat.needsUpdate = true;
        });
      });
   
  // add the bounding box 
          const box = new THREE.Box3().setFromObject(model);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());
          console.log('Bounding box size:', size);
          console.log('Bounding box center:', center);
      
          camera.position.set(center.x, center.y, center.z + size.length());
          controls.target.copy(center);
          controls.update();
  
          const boxHelper = new THREE.BoxHelper(model, 0x888888);
          scene.add(boxHelper);
          const min = box.min;
          const max = box.max;
          const offset = size.length() * 0.1;

          const labelX = createAxisLabelMesh('Galactic X', new THREE.Vector3(min.x + offset, min.y, min.z), new THREE.Euler(0, 0, 0));
          const labelY = createAxisLabelMesh('Galactic Y', new THREE.Vector3(min.x, min.y + offset, min.z), new THREE.Euler(0, 0, Math.PI / 2));
          const labelZ = createAxisLabelMesh('Galactic Z', new THREE.Vector3(min.x, min.y, min.z + offset), new THREE.Euler( 0,  - Math.PI / 2, 0));        
              
          const labelScale = size.length() * 0.002; // 20% of diagonal length
          labelX.scale.set(labelScale, labelScale * 0.5, 1);
          labelY.scale.set(labelScale, labelScale * 0.5, 1);
          labelZ.scale.set(labelScale, labelScale * 0.5, 1);
    
          scene.add(labelX, labelY, labelZ);
          
          const arrowLength = size.length() * 0.2;
          const arrowX = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0), // direction: +X
            box.min,                    // origin: bounding box corner
            arrowLength,
            0xff4444                    // red
          );
          
          const arrowY = new THREE.ArrowHelper(
            new THREE.Vector3(0, 1, 0), // direction: +Y
            box.min,
            arrowLength,
            0x44ff44                    // green
          );
          
          const arrowZ = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, 1), // direction: +Z
            box.min,
            arrowLength,
            0x4444ff                    // blue
          );
          
          scene.add(arrowX, arrowY, arrowZ);
          // Master checkbox that looks the same as other checkboxes
          addGroupToggle(null, 'Show Before State', true);
          
          // Subgroup checkboxes (reuse your existing arrays)
          addGroupToggle(beforeMeshes.AllSystems.concat(afterMeshes.AllSystems), 'All Systems', false, 'AllSystems');
          addGroupToggle(beforeMeshes.Criteria.concat(afterMeshes.Criteria), 'Criteria', false, 'Criteria');
          addGroupToggle(beforeMeshes.IceCrystal.concat(afterMeshes.IceCrystal), 'Ice Crystals', false, 'IceCrystal');
          addGroupToggle(beforeMeshes.SilicateCrystal.concat(afterMeshes.SilicateCrystal), 'Silicate Crystals', false, 'SilicateCrystal');
          addGroupToggle(beforeMeshes.PodTrees.concat(afterMeshes.PodTrees), 'Pod Trees', false, 'PodTrees');
          addGroupToggle(beforeMeshes.PodSystems.concat(afterMeshes.PodSystems), 'Pod Systems', false, 'PodSystems');
          
          // initialize visibility to match initial master checkbox state
          updateVisibility();
          

    
      // Add toggles for each defined group
      //addGroupToggle([pointCloud0], 'AllSystems');  
      //addGroupToggle([pointCloud1], 'Meets criteria No NSP');  
      //addGroupToggle(iceCrystal, 'Ice Crystal Group');
      //addGroupToggle(silicateCrystal, 'Silicate Crystal Group');
      //addGroupToggle(podtreesystems, 'Pod Tree Systems');
      //addGroupToggle(podsystems, 'Pod Systems');
      //addGroupToggle([sphereMesh], 'Minimum Sphere');
      
      const bboxLabel = document.createElement('label');
      bboxLabel.style.display = 'block';
      bboxLabel.style.marginTop = '10px';
      
      const bboxCheckbox = document.createElement('input');
      bboxCheckbox.type = 'checkbox';
      bboxCheckbox.checked = true;
      bboxCheckbox.style.marginRight = '6px';
      
      bboxCheckbox.addEventListener('change', () => {
        const visible = bboxCheckbox.checked;
        boxHelper.visible = visible;
        labelX.visible = visible;
        labelY.visible = visible;
        labelZ.visible = visible;
        console.log('Bounding box and labels visibility set to', visible);
      });
      
      bboxLabel.appendChild(bboxCheckbox);
      bboxLabel.appendChild(document.createTextNode('Show Bounding Box & Labels'));
      ui.appendChild(bboxLabel);
              
    // Opacity slider for mesh 13
    const opacityLabel = document.createElement('label');
    opacityLabel.style.display = 'block';
    opacityLabel.style.marginTop = '10px';
    opacityLabel.textContent = 'Sphere Opacity';
    
    const opacitySlider = document.createElement('input');
    opacitySlider.type = 'range';
    opacitySlider.min = '0';
    opacitySlider.max = '1';
    opacitySlider.step = '0.01';
    opacitySlider.value = '0.3';
    
    opacitySlider.addEventListener('input', () => {
    const value = parseFloat(opacitySlider.value);

  // think this was a check if the sphere hadn't loaded but probbaly not needed    
  if (sphereMesh && sphereMesh.material) {
    const materials = Array.isArray(sphereMesh.material) ? sphereMesh.material : [sphereMesh.material];
    materials.forEach(mat => {
      mat.transparent = true;
      mat.opacity = value;
      mat.depthWrite = false;
      mat.needsUpdate = true;
    });
      } else {
        console.warn('Sphere mesh not yet available');
      }
    });
  
    ui.appendChild(opacityLabel);
    ui.appendChild(opacitySlider);

  }); // â† closes loader.load
 
    
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    //labelX.lookAt(camera.position);
    //labelY.lookAt(camera.position);
    //labelZ.lookAt(camera.position);
  }
  animate();
  
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>
</body>
</html>
