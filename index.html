<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="data:,">
  <meta charset="UTF-8" />
  <title>GLTF Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  //Import modules
  import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
  import { GLTFLoader } from './GLTFLoader.js';
  import { OrbitControls } from './OrbitControls.js';
  
  // renderer , camera, scene, controls
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
 
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
  // Lighting section â€” right after camera
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);
  
  const hemi = new THREE.HemisphereLight(0x88ccff, 0x222244, 0.6);
  scene.add(hemi);
   
  const directional = new THREE.DirectionalLight(0xffffff, 0.2);
  directional.position.set(1, 1, 1);
  scene.add(directional);
    
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  console.log('Attempting to load GLTF...');

  // Functions and helpers
  // Create axis label sprites
    function createAxisLabel(text, position, color = 0xffffff) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      context.font = '24px sans-serif';
      context.fillStyle = 'white';
      context.fillText(text, 0, 24);
    
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, color });
      const sprite = new THREE.Sprite(material);
      sprite.position.copy(position);
      sprite.scale.set(100, 50, 1);
      return sprite;
    }

    // funtions Add a toggle for each mesh group
    function addGroupToggle(groupArray, labelText) {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.style.marginTop = '10px';
      
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.style.marginRight = '6px';
      
        checkbox.addEventListener('change', () => {
          groupArray.forEach(mesh => {
            mesh.visible = checkbox.checked;
          });
          console.log(`${labelText} visibility set to`, checkbox.checked);
        });
      
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(labelText));
        ui.appendChild(label);
    }
  // toggle mesh   
    function toggleMeshByIndex(index, visible) {
        if (meshList[index]) {
          meshList[index].visible = visible;
          console.log(`Mesh ${index} visibility set to`, visible);
        }
    }
    
  //set up import of model 
  let meshList = [];
  let sphereMesh = []; // ðŸ‘ˆ this will hold meshList[13] once loaded
  let pointCloud0 = [];
  let pointCloud1 = [];
  let silicateCrystal = [];
  let iceCrystal = [];
  let podsystems = [];
  let podtreesystems = [];

  // load the gtlf file 
  const loader = new GLTFLoader();
  loader.load('https://precambrianmollusc.github.io/IGAU_KeplerRidge_CrystalSurvey/visualization.gltf', gltf => {
    const model = gltf.scene;
    scene.add(model);
    console.log('GLTF loaded:', model);

  // ðŸ” Traverse and log to identoify all scene objects and get rid of any i doint want - I should clean up in the gtlf export!
  scene.traverse(obj => {
    console.log(`Object: ${obj.type}, name: ${obj.name || '(unnamed)'}, visible: ${obj.visible}`);
     if (obj.name === 'mesh14' && obj.type === 'LineSegments') {
      obj.visible = false; // or scene.remove(obj);
      console.log('ðŸ”§ Hiding PyVista bounding box mesh14');
    }

  });
    
  // Traverse the child looking for mesh and points so we can put into groups - at some point need to figure naming in the python export       
    model.traverse(child => {
       if (child.isMesh || child.type === 'Points') {
        meshList.push(child);
        if (child.name === 'mesh0') pointCloud0 = child;
        if (child.name === 'mesh1') pointCloud1 = child;
        if (child.name === 'mesh13') sphereMesh = child;
        if (child.name === 'mesh4' || child.name === 'mesh6' || child.name === 'mesh8'|| child.name === 'mesh10'|| child.name === 'mesh11') {iceCrystal.push(child);}
        if (child.name === 'mesh5' || child.name === 'mesh7' || child.name === 'mesh9'|| child.name === 'mesh12') {silicateCrystal.push(child);}
        if (child.name === 'mesh2' ) {podtreesystems.push(child);}
        if (child.name === 'mesh3' ) {podsystems.push(child);}
        
        console.log(`Mesh ${meshList.length - 1}:`, child.name || '(unnamed)', child);
      }
    });
    
    console.log('Total meshes found:', meshList.length);
    // point cloud for all systems - shoudl be a low opacity blur
    pointCloud0.material.size = 2.0; // make points larger
    pointCloud0.material.opacity = 0.3;
    pointCloud0.material.transparent = true;
    pointCloud0.material.needsUpdate = true;

    // point cloiud for the systems that meet criteria but no SPS  we will make this look like spheres
    const sprite_sphere = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
    sprite_sphere.colorSpace = THREE.SRGBColorSpace; // ensures correct color rendering
    console.log('Sprite loaded:', sprite_sphere);

    pointCloud1.material.map = sprite_sphere;
    pointCloud1.material.size = 10;
    pointCloud1.material.opacity = 0.7;
    pointCloud1.material.transparent = true;
    pointCloud1.material.depthWrite = false; // prevents z-fighting
    pointCloud1.material.needsUpdate = true;
    pointCloud1.material.blending = THREE.AdditiveBlending;

    // set up the sphere for the raduis of NSPs from the center 
    sphereMesh.material.opacity = 0.3;
    sphereMesh.material.transparent = true;
    sphereMesh.material.depthWrite = false;
    sphereMesh.material.needsUpdate = true;

    // set up the renderings for the differenet NSPs 
       silicateCrystal.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.color = new THREE.Color(0x555555);           // slate gray base
            mat.emissive = new THREE.Color(0x111111);        // subtle inner depth
            mat.emissiveIntensity = 0.2;
            mat.metalness = 0.8;                             // high metal content
            mat.roughness = 0.3;                             // polished but not mirror-like
            mat.transparent = false;
            mat.opacity = 1.0;
            mat.depthWrite = true;
            mat.needsUpdate = true;
          });
        });

      iceCrystal.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.emissive = new THREE.Color(0xeeeeff);       // spectral white
            mat.emissiveIntensity = 0.68;                    // brighter than silicates
            mat.transparent = true;
            mat.opacity = 0.5;                              // soft translucency
            mat.depthWrite = false;
            mat.needsUpdate = true;
          });
        });

      podtreesystems.forEach(mesh => {
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            mat.emissive = new THREE.Color(0x00ff66);       // spectral green
            mat.emissiveIntensity = 0.5;
            mat.transparent = true;
            mat.opacity = 0.4;
            mat.depthWrite = false;
            mat.needsUpdate = true;
          });
        });
    
          podsystems.forEach(mesh => {
        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
        materials.forEach(mat => {
          mat.color = new THREE.Color(0xb87333);          // copper base
          mat.emissive = new THREE.Color(0x552200);       // warm inner glow
          mat.emissiveIntensity = 0.3;
          mat.metalness = 0.6;                            // simulate metal surface
          mat.roughness = 0.4;                            // slight polish
          mat.transparent = true;
          mat.opacity = 0.9;
          mat.depthWrite = true;
          mat.needsUpdate = true;
        });
      });
    
    // add the bounding box 
          const box = new THREE.Box3().setFromObject(model);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());
          console.log('Bounding box size:', size);
          console.log('Bounding box center:', center);
      
          camera.position.set(center.x, center.y, center.z + size.length());
          controls.target.copy(center);
          controls.update();
  
          const boxHelper = new THREE.BoxHelper(model, 0x888888);
          scene.add(boxHelper);
          const min = box.min;
          const max = box.max;
          
          const labelX = createAxisLabel('X Galactic', new THREE.Vector3(1000, 0, 0));
          const labelY = createAxisLabel('Z Galactic', new THREE.Vector3(0, 1000, 0));
          const labelZ = createAxisLabel('Y Galactic', new THREE.Vector3(0, 0, 1000));
          scene.add(labelX);
          scene.add(labelY);
          scene.add(labelZ);
         
          const offset = size.length() * 0.05;
          
          labelX.position.set(min.x + offset, min.y, min.z); // along +X
          labelY.position.set(min.x, min.y + offset, min.z); // along +Y
          labelZ.position.set(min.x, min.y, min.z + offset); // along +Z
      
          // rotate along axis 
          labelX.rotation.set(0, 0, 0); // flat, facing along X
          labelY.rotation.set(0, 0, Math.PI / 2); // rotate around Z to align with Y
          labelZ.rotation.set(Math.PI / 2, 0, 0); // rotate around X to align with Z
              
          const labelScale = size.length() * 0.2; // 20% of diagonal length
          labelX.scale.set(labelScale, labelScale * 0.5, 1);
          labelY.scale.set(labelScale, labelScale * 0.5, 1);
          labelZ.scale.set(labelScale, labelScale * 0.5, 1);

    
    // Create a UI container
    const ui = document.createElement('div');
    ui.style.position = 'absolute';
    ui.style.top = '10px';
    ui.style.left = '10px';
    ui.style.background = 'rgba(0,0,0,0.7)';
    ui.style.padding = '10px';
    ui.style.color = 'white';
    ui.style.fontFamily = 'sans-serif';
    ui.style.zIndex = '10';
    document.body.appendChild(ui);
    
  
      // Add toggles for each defined group
      addGroupToggle([pointCloud0], 'AllSystems');  
      addGroupToggle([pointCloud1], 'Meets criteria No NSP');  
      addGroupToggle(iceCrystal, 'Ice Crystal Group');
      addGroupToggle(silicateCrystal, 'Silicate Crystal Group');
      addGroupToggle(podtreesystems, 'Pod Tree Systems');
      addGroupToggle(podsystems, 'Pod Systems');
      addGroupToggle([sphereMesh], 'Minimum Sphere');
      
      const bboxLabel = document.createElement('label');
      bboxLabel.style.display = 'block';
      bboxLabel.style.marginTop = '10px';
      
      const bboxCheckbox = document.createElement('input');
      bboxCheckbox.type = 'checkbox';
      bboxCheckbox.checked = true;
      bboxCheckbox.style.marginRight = '6px';
      
      bboxCheckbox.addEventListener('change', () => {
        const visible = bboxCheckbox.checked;
        boxHelper.visible = visible;
        labelX.visible = visible;
        labelY.visible = visible;
        labelZ.visible = visible;
        console.log('Bounding box and labels visibility set to', visible);
      });
      
      bboxLabel.appendChild(bboxCheckbox);
      bboxLabel.appendChild(document.createTextNode('Show Bounding Box & Labels'));
      ui.appendChild(bboxLabel);
              
    // Opacity slider for mesh 13
    const opacityLabel = document.createElement('label');
    opacityLabel.style.display = 'block';
    opacityLabel.style.marginTop = '10px';
    opacityLabel.textContent = 'Sphere Opacity';
    
    const opacitySlider = document.createElement('input');
    opacitySlider.type = 'range';
    opacitySlider.min = '0';
    opacitySlider.max = '1';
    opacitySlider.step = '0.01';
    opacitySlider.value = '0.3';
    
    opacitySlider.addEventListener('input', () => {
    const value = parseFloat(opacitySlider.value);

  // think this was a check if the sphere hadn't loaded but probbaly not needed    
  if (sphereMesh && sphereMesh.material) {
    const materials = Array.isArray(sphereMesh.material) ? sphereMesh.material : [sphereMesh.material];
    materials.forEach(mat => {
      mat.transparent = true;
      mat.opacity = value;
      mat.depthWrite = false;
      mat.needsUpdate = true;
    });
      } else {
        console.warn('Sphere mesh not yet available');
      }
    });
  
    ui.appendChild(opacityLabel);
    ui.appendChild(opacitySlider);

  }); // â† closes loader.load
 
    
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    //labelX.lookAt(camera.position);
    //labelY.lookAt(camera.position);
    //labelZ.lookAt(camera.position);
  }
  animate();
  
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>
</body>
</html>
