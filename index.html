<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GLTF Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
  import { GLTFLoader } from './GLTFLoader.js';
  import { OrbitControls } from './OrbitControls.js';
  
  console.log('THREE version:', THREE.REVISION);
  console.log('GLTFLoader loaded');

  console.log('Script started');
  console.log('Imports done');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
  scene.add(new THREE.AxesHelper(1000));

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.set(0, 0, 1000);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(1, 1, 1);
  scene.add(directionalLight);

  console.log('Attempting to load GLTF...');
  
  let meshList = [];
  let sphereMesh = []; // ðŸ‘ˆ this will hold meshList[13] once loaded
  let pointCloud0 = [];
  let pointCloud1 = [];
  let silicateCrystal = [];
  let iceCrystal = [];
  let podsystems = [];
  let podtreesystems = [];
  
  const loader = new GLTFLoader();
  loader.load('https://precambrianmollusc.github.io/CrystalGlb_test/visualization.gltf', gltf => {
    const model = gltf.scene;
    scene.add(model);
    console.log('GLTF loaded:', model);
         
    model.traverse(child => {
       if (child.isMesh || child.type === 'Points') {
        meshList.push(child);
        if (child.name === 'mesh0') pointCloud0 = child;
        if (child.name === 'mesh1') pointCloud1 = child;
        if (child.name === 'mesh13') sphereMesh = child;
        if (child.name === 'mesh4' || child.name === 'mesh6' || child.name === 'mesh8'|| child.name === 'mesh10'|| child.name === 'mesh11') {iceCrystal.push(child);}
        if (child.name === 'mesh5' || child.name === 'mesh7' || child.name === 'mesh9'|| child.name === 'mesh12') {silicateCrystal.push(child);}
        if (child.name === 'mesh2' ) {podtreesystems.push(child);}
        if (child.name === 'mesh3' ) {podsystems.push(child);}
        
        console.log(`Mesh ${meshList.length - 1}:`, child.name || '(unnamed)', child);
      }
    });
    
    console.log('Total meshes found:', meshList.length);
       
    pointCloud0.material.size = 2.0; // make points larger
    pointCloud0.material.opacity = 0.3;
    pointCloud0.material.transparent = true;
    pointCloud0.material.needsUpdate = true;
    
    pointCloud1.material.size = 2.5;
    pointCloud1.material.opacity = 0.5;
    pointCloud1.material.transparent = true;
    pointCloud1.material.needsUpdate = true;
    
    sphereMesh.material.opacity = 0.3;
    sphereMesh.material.transparent = true;
    sphereMesh.material.depthWrite = false;
    sphereMesh.material.needsUpdate = true;
    
    // Create a UI container
    const ui = document.createElement('div');
    ui.style.position = 'absolute';
    ui.style.top = '10px';
    ui.style.left = '10px';
    ui.style.background = 'rgba(0,0,0,0.7)';
    ui.style.padding = '10px';
    ui.style.color = 'white';
    ui.style.fontFamily = 'sans-serif';
    ui.style.zIndex = '10';
    document.body.appendChild(ui);
    
      // Add a toggle for each mesh group
      function addGroupToggle(groupArray, labelText) {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.style.marginTop = '10px';
      
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.style.marginRight = '6px';
      
        checkbox.addEventListener('change', () => {
          groupArray.forEach(mesh => {
            mesh.visible = checkbox.checked;
          });
          console.log(`${labelText} visibility set to`, checkbox.checked);
        });
      
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(labelText));
        ui.appendChild(label);
      }
      
      // Add toggles for each defined group
      addGroupToggle([pointCloud0], 'AllSystems');  
      addGroupToggle([pointCloud1], 'Brown Dwarfs');  
      addGroupToggle(iceCrystal, 'Ice Crystal Group');
      addGroupToggle(silicateCrystal, 'Silicate Crystal Group');
      addGroupToggle(podtreesystems, 'Pod Tree Systems');
      addGroupToggle(podsystems, 'Pod Systems');
      addGroupToggle([sphereMesh], 'Minimum Sphere');
    
    // Opacity slider for mesh 13
    const opacityLabel = document.createElement('label');
    opacityLabel.style.display = 'block';
    opacityLabel.style.marginTop = '10px';
    opacityLabel.textContent = 'Sphere Opacity';
    
    const opacitySlider = document.createElement('input');
    opacitySlider.type = 'range';
    opacitySlider.min = '0';
    opacitySlider.max = '1';
    opacitySlider.step = '0.01';
    opacitySlider.value = '0.15';
    
    opacitySlider.addEventListener('input', () => {
    const value = parseFloat(opacitySlider.value);

  if (sphereMesh && sphereMesh.material) {
    const materials = Array.isArray(sphereMesh.material) ? sphereMesh.material : [sphereMesh.material];
    materials.forEach(mat => {
      mat.transparent = true;
      mat.opacity = value;
      mat.depthWrite = false;
      mat.needsUpdate = true;
    });
      } else {
        console.warn('Sphere mesh not yet available');
      }
    });


    ui.appendChild(opacityLabel);
    ui.appendChild(opacitySlider);
   
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    console.log('Bounding box size:', size);
    console.log('Bounding box center:', center);

    camera.position.set(center.x, center.y, center.z + size.length());
    controls.target.copy(center);
  }, undefined, error => {
    console.error('GLTF load error:', error);
  });

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
  
  function toggleMeshByIndex(index, visible) {
    if (meshList[index]) {
      meshList[index].visible = visible;
      console.log(`Mesh ${index} visibility set to`, visible);
    }
  }


  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
