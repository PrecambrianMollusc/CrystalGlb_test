<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GLTF Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
  import { GLTFLoader } from './GLTFLoader.js';
  import { OrbitControls } from './OrbitControls.js';
  
  console.log('THREE version:', THREE.REVISION);
  console.log('GLTFLoader loaded');

  console.log('Script started');
  console.log('Imports done');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
  scene.add(new THREE.AxesHelper(1000));

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.set(0, 0, 1000);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(1, 1, 1);
  scene.add(directionalLight);

  console.log('Attempting to load GLTF...');
  
  let meshList = [];
  let sphereMesh = null; // ðŸ‘ˆ this will hold meshList[13] once loaded
  
  const loader = new GLTFLoader();
  loader.load('https://precambrianmollusc.github.io/CrystalGlb_test/visualization.gltf', gltf => {
    const model = gltf.scene;
    scene.add(model);
    console.log('GLTF loaded:', model);
     
    model.traverse(child => {
      if (child.isMesh) {
       meshList.push(child);
       console.log(`Mesh ${meshList.length - 1}:`, child.name || '(unnamed)', child);
        }
     });
    sphereMesh = meshList[13]; // ðŸ‘ˆ cache the reference
    
    // Create a UI container
    const ui = document.createElement('div');
    ui.style.position = 'absolute';
    ui.style.top = '10px';
    ui.style.left = '10px';
    ui.style.background = 'rgba(0,0,0,0.7)';
    ui.style.padding = '10px';
    ui.style.color = 'white';
    ui.style.fontFamily = 'sans-serif';
    ui.style.zIndex = '10';
    document.body.appendChild(ui);
    
    // Add a checkbox for each mesh
    meshList.forEach((mesh, index) => {
      const label = document.createElement('label');
      label.style.display = 'block';
      label.style.marginBottom = '4px';
    
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = true;
      checkbox.style.marginRight = '6px';
    
      checkbox.addEventListener('change', () => {
        toggleMeshByIndex(index, checkbox.checked);
      });
    
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(mesh.name || `Mesh ${index}`));
      ui.appendChild(label);
    });
    
    // Opacity slider for mesh 13
    const opacityLabel = document.createElement('label');
    opacityLabel.style.display = 'block';
    opacityLabel.style.marginTop = '10px';
    opacityLabel.textContent = 'Sphere Opacity';
    
    const opacitySlider = document.createElement('input');
    opacitySlider.type = 'range';
    opacitySlider.min = '0';
    opacitySlider.max = '1';
    opacitySlider.step = '0.01';
    opacitySlider.value = '0.3';
    
    opacitySlider.addEventListener('input', () => {
    const value = parseFloat(opacitySlider.value);

  if (sphereMesh && sphereMesh.material) {
    const materials = Array.isArray(sphereMesh.material) ? sphereMesh.material : [sphereMesh.material];
    materials.forEach(mat => {
      mat.transparent = true;
      mat.opacity = value;
      mat.depthWrite = false;
      mat.needsUpdate = true;
    });
      } else {
        console.warn('Sphere mesh not yet available');
      }
    });


    ui.appendChild(opacityLabel);
    ui.appendChild(opacitySlider);

    
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    console.log('Bounding box size:', size);
    console.log('Bounding box center:', center);

    camera.position.set(center.x, center.y, center.z + size.length());
    controls.target.copy(center);
  }, undefined, error => {
    console.error('GLTF load error:', error);
  });

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
  
  function toggleMeshByIndex(index, visible) {
    if (meshList[index]) {
      meshList[index].visible = visible;
      console.log(`Mesh ${index} visibility set to`, visible);
    }
  }


  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
